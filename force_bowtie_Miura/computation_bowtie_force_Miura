from firedrake import *
import sys
from firedrake.output import *
from firedrake.petsc import PETSc

# Create mesh
#N = 20 #80 computation #10 #debug
#mesh = UnitSquareMesh(N, N, diagonal='crossed')
mesh = Mesh('mesh.msh')

# Define function spaces
V = VectorFunctionSpace(mesh, "CG", 2)
W = FunctionSpace(mesh, "CG", 1)
Z = V * W
PETSc.Sys.Print('Nb dof: %i' % Z.dim())

#Define the boundary conditions
q0 = 0.25
x = SpatialCoordinate(mesh)
#BC
boundary_CL = as_vector((x[0] + q0, x[1]))
boundary_CR = as_vector((x[0] - q0, x[1]))
bcs = [DirichletBC(V, boundary_CL, 1), DirichletBC(V, boundary_CR, 2)]

#Interior penalty
# alpha = Constant(0.05) #1e2 #10 #penalty parameter
alpha = Constant(0.1)
h = CellDiameter(mesh) # cell diameter
h_avg = avg(h)  # average size of cells sharing a facet
n = FacetNormal(mesh) # outward-facing normal vector

#Initial guess for deformation
sol_ig = Function(V, name='IG')
v_basis = VectorSpaceBasis(constant=True, comm=COMM_WORLD)
sol_ig.interpolate(as_vector(((1-2*q0)*x[0] + q0, x[1])))

#Compute initial guess for the angle field
theta_ig = Function(W, name='IG theta')
# basis vectors & reference/deformed Bravais lattice vectors & metric tensor
phi = pi/6
e_1 = Constant((1, 0))
e_2 = Constant((0, 1))
u_s = sqrt(3) * cos(phi/2)
v_s = 2 * sqrt( 2/ ( 5-3 * cos(phi) ) )
u_0 = u_s * e_1
v_0 = v_s * e_2
u_ts = sqrt(3) * cos( (theta_ig+phi)/2 )
v_ts = 2 * sqrt( 2/ ( 5-3 * cos(theta_ig+phi) ) )
A_t = as_matrix( [ [ u_ts/ u_s, 0], [0, v_ts/v_s] ] )

# elastic parameters
c_1 = 1.0  # metric constraint
d_2, d_3 = 1e-2, 1e-2
d_1 = 0.1
# c_1 = 5.0  # metric constraint
# d_2, d_3 = 5e-2, 5e-2
# d_1 = 0.1
c = 1.0

#defining the energy to minimize
L = dot(grad(sol_ig).T, grad(sol_ig)) - dot(A_t.T, A_t)
# J_t = sqrt(det(dot(grad(sol_ig).T, grad(sol_ig))))
energy = inner(L, L) * dx + c * inner(grad(theta_ig), grad(theta_ig)) * dx
zeta = TestFunction(W)
a = derivative(energy, theta_ig, zeta)

#Solve
solve(a == 0, theta_ig, solver_parameters={'quadrature_degree': '2'}) #'snes_monitor': None, 'snes_max_it': 10})

# PETSc.Sys.Print('Initial guess ok!\n')

#Output initial guess
WW = VectorFunctionSpace(mesh, 'CG', 1, dim=2)
disp_ig = Function(WW, name='yeff 2d')
disp_ig.interpolate(sol_ig-as_vector((x[0], x[1])))

outfile_i = VTKFile("IG.pvd")
outfile_i.write(disp_ig, theta_ig)

# Nonlinear problem
# Define trial and test functions
test = TestFunction(Z)
w, eta = split(test)

# Define solutions
sol = Function(Z, name='sol')
y, theta = split(sol)

# Interpolate initial guess
sol.sub(0).interpolate(sol_ig)
# Go get code from Hu for the computation of theta
sol.sub(1).interpolate(theta_ig)

# Define the boundary conditions
bcs_ = [DirichletBC(Z.sub(0), boundary_CL, 1), DirichletBC(Z.sub(0), boundary_CR, 2)]

# basis vectors & reference/deformed Bravais lattice vectors & metric tensor
u_t = sqrt(3.0) * cos((theta + phi) / 2.0)
v_t = 2.0 * sqrt(2.0 / (5.0 - 3.0 * cos(theta + phi)))
A = as_matrix([[u_t / u_s, 0.0], [0.0, v_t / v_s]])

# Preparation for variational form
H = variable(grad(grad(y)))
# N = cross(y.dx(0), y.dx(1))
# N /= sqrt(inner(N, N))
L = dot(grad(y).T, grad(y)) - dot(A.T, A)
J = sqrt(det(dot(grad(y).T, grad(y))))

# Total energy
dens = c_1 * inner(L, L)/J + d_1 * theta ** 2 + d_2 * inner(grad(theta), grad(theta)) + d_3 * inner(H, H)  # test
G = diff(dens, H)
Energy = dens * dx

# first variation of the energy
a = derivative(Energy, sol, test)

# interior penalty
a -= inner(dot(avg(G), n('+')), jump(grad(w))) * dS  # consistency term
a += alpha / h_avg * inner(jump(grad(y)), jump(grad(w))) * dS  # pen term

# Solve
# parameters={"snes_monitor": None, "ksp_type": "preonly", "mat_type": "aij", "pc_type": "lu", "pc_factor_mat_solver_type": "mumps"}
parameters = {'snes_monitor': None, 'snes_max_it': 25, 'quadrature_degree': '4'}  # , "pc_type": "lu", "pc_factor_mat_solver_type": "mumps"}
nullspace = MixedVectorSpaceBasis(Z, [v_basis, Z.sub(1)])
try:
    solve(a == 0, sol, bcs=bcs_, nullspace=nullspace, solver_parameters=parameters)
except ConvergenceError:  # firedrake.exceptions.ConvergenceError:
    en = assemble(c_1 * inner(L, L) * dx)
    print(en)
    en = assemble(d_1 * theta ** 2 * dx)
    print(en)
    en = assemble(d_2 * inner(grad(theta), grad(theta)) * dx)
    print(en)
    en = assemble(d_3 * inner(H, H) * dx)
    print(en)
    sys.exit()

# plotting the results
disp = Function(WW, name='yeff 2d')
disp.interpolate(sol.sub(0) - as_vector((x[0], x[1])))
ang = Function(W, name='theta')
ang.assign(sol.sub(1))

outfile = VTKFile("output.pvd")
outfile.write(disp, ang)

# Computing reaction forces
v_reac = Function(Z)
bc_l = DirichletBC(V.sub(0), Constant(1), 1)
bc_l.apply(v_reac.sub(0))
res_l = assemble(action(a, v_reac))
print('Reaction on the left: %.3e' % res_l)
# sys.exit()
v_reac.sub(0).interpolate(Constant((0, 0)))
bc_r = DirichletBC(V.sub(0), Constant(1), 2)
bc_r.apply(v_reac.sub(0))
res_r = assemble(action(a, v_reac))
print('Reaction on the right: %.3e' % res_r)
PETSc.Sys.Print('Total force: %.3e' % (res_l + res_r))
# print(f"Reaction on the left = {res_l: .3e}")
